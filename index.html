<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>$GLITCH -  Move betweenn the frames</title>
<link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">

<style>
    body {
        margin: 0;
        overflow-x: hidden;
        background: radial-gradient(ellipse at center, #100518 0%, #020104 70%);
        color: #00ffcc;
        font-family: 'Share Tech Mono', monospace;
    }
    html { scroll-behavior: smooth; }
    #nav {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 200;
        display: flex;
        justify-content: center;
        gap: 28px;
        padding: 14px 18px;
        background: rgba(2, 1, 4, 0.35);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border-bottom: 1px solid rgba(0,255,204,0.12);
    }
    #nav a {
        color: #00ffcc;
        text-decoration: none;
        letter-spacing: 1px;
        font-size: 18px;
        transition: color 0.2s ease;
    }
    #nav a:hover { color: #ffffff; }

    #nav-subtitle {
        position: fixed;
        top: 52px;
        left: 0;
        right: 0;
        z-index: 199;
        text-align: center;
        color: rgba(204,255,251,0.9);
        font-size: 18px;
        letter-spacing: 1px;
        pointer-events: none;
        text-shadow: 0 0 6px rgba(0,255,204,0.25);
    }

    #hero {
        position: relative;
        height: 80vh;
        width: 100vw;
        overflow: hidden;
    }
    canvas {
        display: block;
        width: 100%;
        height: 100%;
    }
    #info {
        position: absolute;
        top: 70px;
        left: 0;
        width: 100%;
        text-align: center;
        color: rgba(0, 255, 204, 0.9);
        font-size: 29px;
        letter-spacing: 2px;
        pointer-events: none;
        z-index: 100;
        text-shadow: 0 0 8px rgba(0, 255, 204, 0.7), 0 0 12px rgba(0, 255, 204, 0.5);
        transition: opacity 2s ease-in-out 1s;
    }
    #info span { font-size: 18px; }

    @property --angle {
      syntax: '<angle>';
      initial-value: 0deg;
      inherits: false;
    }

    #glitch-button {
        position: absolute;
        z-index: 101;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
        padding: 12px 24px;
        border: none;
        border-radius: 8px;
        color: #00ffcc;
        font-family: 'Share Tech Mono', monospace;
        font-size: 21px;
        letter-spacing: 1px;
        cursor: pointer;
        transition: color 0.3s ease, box-shadow 0.3s ease;
        overflow: hidden;
        background: transparent;
    }

    #glitch-button::before {
        content: '';
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        background: conic-gradient(from var(--angle), #020104, #ff00ff, #00ffcc, #ff00ff, #020104);
        animation: rotateBorder 4s linear infinite;
        z-index: -2;
        border-radius: 8px;
    }

    #glitch-button::after {
        content: '';
        position: absolute;
        top: 2px; left: 2px;
        width: calc(100% - 4px);
        height: calc(100% - 4px);
        background: rgba(0, 255, 204, 0.1);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border-radius: 6px;
        z-index: -1;
    }

    @keyframes rotateBorder {
        to {
            --angle: 360deg;
        }
    }

    #glitch-button:hover {
        color: #ffffff;
        box-shadow: 0 0 25px rgba(0, 255, 204, 0.5);
    }

    /* Liquid glass scroll gutters */
    .hero-gutter {
        position: absolute;
        top: 0;
        bottom: 0;
        width: min(8vw, 100px);
        z-index: 102;
        pointer-events: auto;
        background: radial-gradient(120% 80% at 50% 20%, rgba(0,255,204,0.14), rgba(255,0,255,0.10) 40%, rgba(0,0,0,0.12) 100%);
        backdrop-filter: blur(8px) saturate(110%);
        -webkit-backdrop-filter: blur(8px) saturate(110%);
        border: 1px solid rgba(0,255,204,0.18);
        box-shadow: inset 0 0 20px rgba(0,255,204,0.10), 0 0 24px rgba(0,255,204,0.08);
    }
    .hero-gutter.left { left: 0; border-right: 1px solid rgba(0,255,204,0.14); border-top-right-radius: 16px; border-bottom-right-radius: 16px; }
    .hero-gutter.right { right: 0; border-left: 1px solid rgba(255,0,255,0.14); border-top-left-radius: 16px; border-bottom-left-radius: 16px; }
    .hero-gutter::before {
        content: '';
        position: absolute;
        inset: -2px;
        border-radius: inherit;
        background: conic-gradient(from var(--angle), rgba(2,1,4,0), rgba(0,255,204,0.35), rgba(255,0,255,0.35), rgba(2,1,4,0));
        animation: rotateBorder 8s linear infinite;
        filter: blur(6px);
        z-index: -1;
        opacity: 0.3;
    }
    .gutter-text {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 6px;
        font-size: 26px;
        color: rgba(204,255,251,0.8);
        text-transform: uppercase;
        text-shadow: 0 0 6px rgba(0,255,204,0.25);
        pointer-events: none;
        user-select: none;
        opacity: 0.6;
        transition: opacity 0.3s ease;
    }
    .hero-gutter:hover .gutter-text { opacity: 0.9; }
    .gutter-text span { display: block; }
    @media (max-width: 900px) {
        .hero-gutter { width: min(10vw, 84px); }
    }
    @media (max-width: 640px) {
        .hero-gutter { width: 48px; }
        .gutter-text { font-size: 10px; gap: 5px; }
    }

    .section {
        min-height: 60vh;
        padding: 56px 40px 48px;
        max-width: 1100px;
        margin: 0 auto;
        line-height: 1.5;
        text-align: center;
        scroll-snap-align: start;
        scroll-margin-top: 64px;
        opacity: 0;
        transform: translateY(12px);
        transition: opacity 0.6s ease, transform 0.6s ease;
    }
    
    .section.compact {
        min-height: auto;
        padding: 24px 40px;
    }
    .section.in-view { opacity: 1; transform: none; }
    .section h2 {
        margin-top: 0;
        font-size: 47px;
        letter-spacing: 2px;
        color: #ccfffb;
        text-shadow: 0 0 8px rgba(0,255,204,0.25);
    }
    .section p { color: rgba(204,255,251,0.85); font-size: 27px; }
    .cards { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 18px; }
    .card { border: 1px solid rgba(0,255,204,0.15); padding: 21px; border-radius: 13px; background: rgba(0,0,0,0.25); text-align: center; font-size: 1.3em; }
    .glitch-card { position: relative; padding: 24px; border-radius: 12px; border: 1px solid rgba(0,255,204,0.2); background: rgba(0, 0, 0, 0.3); }
    .glitch-card::before { content: ''; position: absolute; inset: -1px; border-radius: 12px; background: conic-gradient(from var(--angle), #020104, #ff00ff, #00ffcc, #ff00ff, #020104); animation: rotateBorder 6s linear infinite; z-index: -2; opacity: 0.25; }
    .glitch-card::after { content: ''; position: absolute; inset: 1px; border-radius: 10px; background: rgba(0, 0, 0, 0.35); z-index: -1; }

    /* Ordered list centering */
    .section ol { list-style-position: inside; margin: 0 auto; padding: 0; text-align: center; max-width: 720px; font-size: 27px; }
    .section ol li { margin: 10px 0; }

    /* Button */
    .btn { position: relative; display: inline-block; padding: 12px 20px; border-radius: 10px; color: #00ffcc; text-decoration: none; letter-spacing: 1px; overflow: hidden; transition: color 0.2s ease; }
    .btn::before { content: ''; position: absolute; inset: 0; border-radius: 10px; background: conic-gradient(from var(--angle), #020104, #ff00ff, #00ffcc, #ff00ff, #020104); animation: rotateBorder 5s linear infinite; z-index: -2; }
    .btn::after { content: ''; position: absolute; inset: 2px; border-radius: 8px; background: rgba(0, 255, 204, 0.08); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); z-index: -1; }
    .btn:hover { color: #ffffff; }

    /* Glitch Diagrams */
    .glitch-diagrams {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 24px;
        margin: 32px 0;
    }
    
    .glitch-diagram {
        position: relative;
        padding: 24px;
        border-radius: 12px;
        border: 1px solid rgba(0,255,204,0.2);
        background: rgba(0, 0, 0, 0.3);
        overflow: hidden;
    }
    
    .glitch-diagram::before {
        content: '';
        position: absolute;
        inset: -1px;
        border-radius: 12px;
        background: conic-gradient(from var(--angle), #020104, #ff00ff, #00ffcc, #ff00ff, #020104);
        animation: rotateBorder 6s linear infinite;
        z-index: -2;
        opacity: 0.25;
    }
    
    .glitch-diagram::after {
        content: '';
        position: absolute;
        inset: 1px;
        border-radius: 10px;
        background: rgba(0, 0, 0, 0.35);
        z-index: -1;
    }
    
    .diagram-title {
        font-size: 20px;
        color: #00ffcc;
        margin-bottom: 16px;
        text-align: center;
        text-shadow: 0 0 8px rgba(0,255,204,0.25);
    }
    
    .glitch-meter {
        position: relative;
        height: 120px;
        background: linear-gradient(90deg, #020104 0%, #ff00ff 25%, #00ffcc 50%, #ff00ff 75%, #020104 100%);
        border-radius: 8px;
        overflow: hidden;
        margin: 16px 0;
    }
    
    .glitch-level {
        position: absolute;
        top: 0;
        left: 0;
        height: 100%;
        width: 83%;
        background: linear-gradient(90deg, rgba(0,255,204,0.8) 0%, rgba(255,0,255,0.8) 50%, rgba(0,255,204,0.8) 100%);
        border-radius: 8px;
        animation: glitchPulse 2s ease-in-out infinite, glitchFluctuate 3s ease-in-out infinite;
        transition: width 0.5s ease;
    }
    
    .glitch-level::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: repeating-linear-gradient(
            90deg,
            transparent 0px,
            rgba(255,255,255,0.1) 2px,
            transparent 4px
        );
        animation: glitchScan 0.5s linear infinite;
    }
    
    .glitch-percentage {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 24px;
        font-weight: bold;
        color: #ffffff;
        text-shadow: 0 0 10px rgba(0,255,204,0.8);
    }
    
    .glitch-spectrum {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin: 16px 0;
    }
    
    .spectrum-bar {
        height: 20px;
        border-radius: 10px;
        position: relative;
        overflow: hidden;
        animation: spectrumPulse 1s ease-in-out infinite;
    }
    
    .spectrum-bar:nth-child(1) { 
        animation: spectrumPulse 1.5s ease-in-out infinite;
        animation-delay: 0s;
    }
    .spectrum-bar:nth-child(2) { 
        animation: spectrumPulse 2.2s ease-in-out infinite;
        animation-delay: 0.3s;
    }
    .spectrum-bar:nth-child(3) { 
        animation: spectrumPulse 1.8s ease-in-out infinite;
        animation-delay: 0.6s;
    }
    .spectrum-bar:nth-child(4) { 
        animation: spectrumPulse 2.6s ease-in-out infinite;
        animation-delay: 0.9s;
    }
    .spectrum-bar:nth-child(5) { 
        animation: spectrumPulse 1.9s ease-in-out infinite;
        animation-delay: 1.2s;
    }
    
    .spectrum-bar:nth-child(1) { background: linear-gradient(90deg, #ff00ff 0%, #ff00ff 100%); }
    .spectrum-bar:nth-child(2) { background: linear-gradient(90deg, #ff00ff 0%, #00ffcc 100%); }
    .spectrum-bar:nth-child(3) { background: linear-gradient(90deg, #00ffcc 0%, #00ffcc 100%); }
    .spectrum-bar:nth-child(4) { background: linear-gradient(90deg, #00ffcc 0%, #ff00ff 100%); }
    .spectrum-bar:nth-child(5) { background: linear-gradient(90deg, #ff00ff 0%, #ff00ff 100%); }
    
    .spectrum-bar::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: repeating-linear-gradient(
            90deg,
            transparent 0px,
            rgba(255,255,255,0.5) 1px,
            transparent 2px
        );
        animation: spectrumGlitch 0.15s linear infinite;
    }
    
    .spectrum-bar::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.15) 50%, transparent 100%);
        animation: spectrumSweep 2s ease-in-out infinite;
    }
    
    .spectrum-bar:nth-child(1)::after { 
        animation: spectrumSweep 2.8s ease-in-out infinite;
        animation-delay: 0s; 
    }
    .spectrum-bar:nth-child(2)::after { 
        animation: spectrumSweep 3.5s ease-in-out infinite;
        animation-delay: 0.5s; 
    }
    .spectrum-bar:nth-child(3)::after { 
        animation: spectrumSweep 3.0s ease-in-out infinite;
        animation-delay: 1.0s; 
    }
    .spectrum-bar:nth-child(4)::after { 
        animation: spectrumSweep 4.0s ease-in-out infinite;
        animation-delay: 1.5s; 
    }
    .spectrum-bar:nth-child(5)::after { 
        animation: spectrumSweep 2.9s ease-in-out infinite;
        animation-delay: 2.0s; 
    }
    
    .spectrum-label {
        position: absolute;
        right: -60px;
        top: 50%;
        transform: translateY(-50%);
        font-size: 12px;
        color: rgba(204,255,251,0.8);
    }
    
    @keyframes glitchPulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
    }
    
    @keyframes glitchFluctuate {
        0% { width: 80%; }
        25% { width: 84%; }
        50% { width: 82%; }
        75% { width: 86%; }
        100% { width: 80%; }
    }
    
    @keyframes glitchScan {
        0% { transform: translateX(-100%); }
        100% { transform: translateX(100%); }
    }
    
    @keyframes spectrumGlitch {
        0% { transform: translateX(-2px); }
        50% { transform: translateX(2px); }
        100% { transform: translateX(-2px); }
    }
    
    @keyframes spectrumSweep {
        0% { transform: translateX(-100%); opacity: 0; }
        50% { opacity: 1; }
        100% { transform: translateX(100%); opacity: 0; }
    }
    
    .glitch-text {
        animation: textGlitch 2s ease-in-out infinite, textFlicker 0.1s linear infinite;
        position: relative;
    }
    
    .glitch-text::before,
    .glitch-text::after {
        content: attr(data-text);
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: transparent;
    }
    
    .glitch-text::before {
        animation: glitchBefore 0.3s linear infinite;
        color: #ff00ff;
        z-index: -1;
    }
    
    .glitch-text::after {
        animation: glitchAfter 0.3s linear infinite;
        color: #00ffcc;
        z-index: -2;
    }
    
    @keyframes spectrumPulse {
        0%, 100% { 
            transform: scaleX(1);
            opacity: 0.8;
        }
        25% { 
            transform: scaleX(0.3);
            opacity: 0.4;
        }
        50% { 
            transform: scaleX(0.7);
            opacity: 0.9;
        }
        75% { 
            transform: scaleX(0.5);
            opacity: 0.6;
        }
    }
    
    @keyframes textGlitch {
        0%, 100% { transform: translate(0); }
        20% { transform: translate(-2px, 2px); }
        40% { transform: translate(-2px, -2px); }
        60% { transform: translate(2px, 2px); }
        80% { transform: translate(2px, -2px); }
    }
    
    @keyframes textFlicker {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.8; }
    }
    
    @keyframes glitchBefore {
        0% { transform: translate(0); }
        20% { transform: translate(-2px, 2px); }
        40% { transform: translate(-2px, -2px); }
        60% { transform: translate(2px, 2px); }
        80% { transform: translate(2px, -2px); }
        100% { transform: translate(0); }
    }
    
    @keyframes glitchAfter {
        0% { transform: translate(0); }
        20% { transform: translate(2px, -2px); }
        40% { transform: translate(2px, 2px); }
        60% { transform: translate(-2px, -2px); }
        80% { transform: translate(-2px, 2px); }
        100% { transform: translate(0); }
    }

    @media (max-width: 640px) {
        #info { font-size: 18px; top: 64px; }
        #info span { font-size: 12px; }
        #glitch-button { font-size: 14px; padding: 10px 20px; bottom: 20px; }
        #hero { height: 70vh; }
        .section { min-height: 60vh; padding: 48px 24px 40px; scroll-margin-top: 60px; }
        .section h2 { font-size: 30px; }
        .section p { font-size: 19px; }
    }
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
  }
}
</script>

<nav id="nav">
    <a href="#hero">HOME</a>
    <a href="#benefits">BENEFITS</a>
    <a href="#tokenomics">TOKENOMICS</a>
    <a href="#how">ABOUT US</a>
    <a href="#community">COMMUNITY</a>
    <a href="#cta">BUY $GLITCH</a>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    </nav>


<section id="hero">
    <div id="info">
        GLITCH PLANET — $GLITCH<br>
        <span style="font-size: 14px; opacity: 0.8;">[DRAG TO SHIFT PERSPECTIVE • CLICK TO GLITCH]</span>
    </div>
    <button id="glitch-button">TRIGGER GLITCH</button>
    <div class="hero-gutter left"><div class="gutter-text"><span>S</span><span>C</span><span>R</span><span>O</span><span>L</span><span>L</span></div></div>
    <div class="hero-gutter right"><div class="gutter-text"><span>S</span><span>C</span><span>R</span><span>O</span><span>L</span><span>L</span></div></div>
</section>

<section id="benefits" class="section">
    <h2 class="glitch-text" data-text="Why Hold $GLITCH">Why Hold $GLITCH</h2>
    <div class="cards">
        <div class="card"><strong>Community Power</strong><br>Join a high-signal, builder-heavy Solana community orbiting Glitch Planet.</div>
        <div class="card"><strong>Utility Events</strong><br>Access periodic on-chain events, raffles, and challenges tied to $GLITCH.</div>
        <div class="card"><strong>Art + Lore</strong><br>Exclusive drops expanding the Glitch Planet mythos and visuals.</div>
        <div class="card"><strong>Early Access</strong><br>Priority for future experiments, tools, and collabs.</div>
    </div>
</section>

<section id="tokenomics" class="section compact">
    <div class="glitch-card" style="margin-bottom: 60px;">
        <p class="glitch-text" data-text="Solana moves fast. $GLITCH moves between the frames." style="font-size:28px; font-weight:700; text-shadow: 0 0 8px rgba(0,255,204,0.25); margin: 0;">
            Solana moves fast. $GLITCH moves between the frames.
        </p>
    </div>
    
    
    
    
    
</section>

<section id="how" class="section">
    <h2 class="glitch-text" data-text="About Us">About Us</h2>
    <p>We are the architects of Glitch Planet, a digital realm where reality bends and crypto meets the cosmos.</p>
    <p>Born from the chaos of market volatility, we've created $GLITCH as a token that moves between the frames of conventional trading, bridging traditional finance with the infinite possibilities of blockchain.</p>
    <p>Join our community of forward-thinking individuals as we navigate the singularity of decentralized finance, one glitch at a time.</p>
    
    <div class="glitch-diagrams">
        <div class="glitch-diagram">
            <div class="diagram-title">GLITCH LEVEL METER</div>
            <div class="glitch-meter">
                <div class="glitch-level"></div>
                <div class="glitch-percentage" id="glitch-percentage">83%</div>
            </div>
            <p style="text-align: center; font-size: 14px; color: rgba(204,255,251,0.7); margin-top: 12px;">
                Current glitch saturation in Glitch Planet
            </p>
        </div>
        
        <div class="glitch-diagram">
            <div class="diagram-title">GLITCH SPECTRUM ANALYSIS</div>
            <div class="glitch-spectrum">
                <div class="spectrum-bar">
                    <span class="spectrum-label">Quantum</span>
                </div>
                <div class="spectrum-bar">
                    <span class="spectrum-label">Digital</span>
                </div>
                <div class="spectrum-bar">
                    <span class="spectrum-label">Reality</span>
                </div>
                <div class="spectrum-bar">
                    <span class="spectrum-label">Cosmic</span>
                </div>
                <div class="spectrum-bar">
                    <span class="spectrum-label">Singularity</span>
                </div>
            </div>
            <p style="text-align: center; font-size: 14px; color: rgba(204,255,251,0.7); margin-top: 12px;">
                Multi-dimensional glitch frequency distribution
            </p>
        </div>
    </div>
</section>

<section id="community" class="section">
    <div class="glitch-card">
        <h2 class="glitch-text" data-text="Community">Community</h2>
        <p>Follow announcements and join the conversation.</p>
        <a class="btn" href="#" target="_blank" rel="noopener">Follow on X (Twitter)</a>
    </div>
</section>

<section id="cta" class="section">
    <h2>Ready to Enter the Singularity?</h2>
    <p>Scroll back to the top and trigger the glitch. Welcome to Glitch Planet.</p>
    <p>CA: EQHsthN7T7VBCfvgmCt3nmVN63W7St3NW4vZfN7Apump</p>
</section>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

const BLACK_HOLE_RADIUS = 1.3;
const DISK_INNER_RADIUS = BLACK_HOLE_RADIUS + 0.2;
const DISK_OUTER_RADIUS = 8.0;
const DISK_TILT_ANGLE = Math.PI / 3.0;

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x020104, 0.035);
const hero = document.getElementById('hero');
const camera = new THREE.PerspectiveCamera(60, hero.clientWidth / hero.clientHeight, 0.1, 4000);
camera.position.set(-6.5, 5.0, 6.5);

const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
renderer.setSize(hero.clientWidth, hero.clientHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.2;
hero.appendChild(renderer.domElement);

const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));

const bloomPass = new UnrealBloomPass(
    new THREE.Vector2(hero.clientWidth, hero.clientHeight),
    0.6, 0.7, 0.2
);
composer.addPass(bloomPass);

const lensingShader = {
    uniforms: {
        "tDiffuse": { value: null },
        "blackHoleScreenPos": { value: new THREE.Vector2(0.5, 0.5) },
        "lensingStrength": { value: 0.12 }, "lensingRadius": { value: 0.3 },
        "aspectRatio": { value: hero.clientWidth / hero.clientHeight },
        "chromaticAberration": { value: 0.015 }, "scanlineIntensity": { value: 0.15 },
        "vignetteDarkness": { value: 0.8 }
    },
    vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
    fragmentShader: `
        uniform sampler2D tDiffuse; uniform vec2 blackHoleScreenPos; uniform float lensingStrength;
        uniform float lensingRadius; uniform float aspectRatio; uniform float chromaticAberration;
        uniform float scanlineIntensity; uniform float vignetteDarkness; varying vec2 vUv;
        void main() {
            vec2 screenPos = vUv; vec2 toCenter = screenPos - blackHoleScreenPos;
            toCenter.x *= aspectRatio; float dist = length(toCenter);
            float distortionAmount = lensingStrength / (dist * dist + 0.003);
            distortionAmount = clamp(distortionAmount, 0.0, 0.7);
            float falloff = smoothstep(lensingRadius, lensingRadius * 0.3, dist);
            distortionAmount *= falloff; vec2 offset = normalize(toCenter) * distortionAmount;
            offset.x /= aspectRatio; vec2 distortedUvR = screenPos - offset * (1.0 + chromaticAberration);
            vec2 distortedUvG = screenPos - offset; vec2 distortedUvB = screenPos - offset * (1.0 - chromaticAberration);
            float r = texture2D(tDiffuse, distortedUvR).r; float g = texture2D(tDiffuse, distortedUvG).g;
            float b = texture2D(tDiffuse, distortedUvB).b; vec3 finalColor = vec3(r, g, b);
            float scanline = sin(vUv.y * 800.0) * 0.5 + 0.5;
            finalColor.rgb -= scanline * scanlineIntensity * finalColor.rgb;
            float vignette = length(vUv - vec2(0.5)); finalColor *= (1.0 - vignette * vignetteDarkness);
            gl_FragColor = vec4(finalColor, 1.0);
        }`
};
const lensingPass = new ShaderPass(lensingShader);
composer.addPass(lensingPass);

const CustomGlitchShader = {
    uniforms: {
        'tDiffuse': { value: null },
        'uIntensity': { value: 0.0 },
        'uTime': { value: 0.0 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }`,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float uIntensity;
        uniform float uTime;
        varying vec2 vUv;

        float random(vec2 p) {
            return fract(sin(dot(p.xy, vec2(12.9898, 78.233))) * 43758.5453);
        }

        void main() {
            vec2 uv = vUv;
            vec3 finalColor;

            float r_offset = (random(uv + uTime * 0.4) - 0.5) * 0.05 * uIntensity;
            float g_offset = (random(uv + uTime * 0.6) - 0.5) * 0.05 * uIntensity;

            vec2 uvR = uv + vec2(r_offset, 0.0);
            vec2 uvG = uv + vec2(g_offset, 0.0);
            vec2 uvB = uv;

            float r = texture2D(tDiffuse, uvR).r;
            float g = texture2D(tDiffuse, uvG).g;
            float b = texture2D(tDiffuse, uvB).b;
            
            finalColor = vec3(r, g, b);

            float line_y = floor(uv.y * 50.0 + uTime * 20.0);
            float line_shift = (random(vec2(line_y, uTime)) - 0.5) * 0.1 * uIntensity;

            if (random(vec2(line_y, uTime * 2.0)) > 0.97 - (uIntensity * 0.3)) {
                finalColor = texture2D(tDiffuse, vec2(uv.x + line_shift, uv.y)).rgb;
            }

            vec3 originalColor = texture2D(tDiffuse, vUv).rgb;
            gl_FragColor = vec4(mix(originalColor, finalColor, uIntensity), 1.0);
        }`
};
const customGlitchPass = new ShaderPass(CustomGlitchShader);
customGlitchPass.enabled = false;
composer.addPass(customGlitchPass);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true; controls.dampingFactor = 0.035;
controls.rotateSpeed = 0.4; controls.autoRotate = false;
controls.autoRotateSpeed = 0.1; controls.target.set(0, 0, 0);
controls.minDistance = 2.5; controls.maxDistance = 100;
controls.enablePan = false;
// Re-enable wheel zoom on the scene
controls.enableZoom = true;
controls.zoomSpeed = 0.6;
// Allow two-finger rotate on touch; single-finger will scroll page
controls.touches = { ONE: THREE.TOUCH.PAN, TWO: THREE.TOUCH.ROTATE };
controls.update();

const starGeometry = new THREE.BufferGeometry();
const starCount = 150000;
const starPositions = new Float32Array(starCount * 3);
const starColors = new Float32Array(starCount * 3);
const starSizes = new Float32Array(starCount);
const starTwinkle = new Float32Array(starCount);
const starFieldRadius = 2000;
const starPalette = [
    new THREE.Color(0x00ffff), new THREE.Color(0xff00ff),
    new THREE.Color(0x8A2BE2), new THREE.Color(0x00ff7f),
    new THREE.Color(0xccddff),
];
for (let i = 0; i < starCount; i++) {
    const i3 = i * 3;
    const phi = Math.acos(-1 + (2 * i) / starCount);
    const theta = Math.sqrt(starCount * Math.PI) * phi;
    const radius = Math.cbrt(Math.random()) * starFieldRadius + 100;
    starPositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
    starPositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
    starPositions[i3 + 2] = radius * Math.cos(phi);
    const starColor = starPalette[Math.floor(Math.random() * starPalette.length)].clone();
    starColor.multiplyScalar(Math.random() * 0.7 + 0.3);
    starColors[i3] = starColor.r; starColors[i3 + 1] = starColor.g; starColors[i3 + 2] = starColor.b;
    starSizes[i] = THREE.MathUtils.randFloat(0.8, 2.5);
    starTwinkle[i] = Math.random() * Math.PI * 2;
}
starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
starGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));
starGeometry.setAttribute('twinkle', new THREE.BufferAttribute(starTwinkle, 1));

const starMaterial = new THREE.ShaderMaterial({
    uniforms: { uTime: { value: 0 }, uPixelRatio: { value: renderer.getPixelRatio() } },
    vertexShader: `
        uniform float uTime; uniform float uPixelRatio;
        attribute float size; attribute float twinkle;
        varying vec3 vColor; varying float vTwinkle;
        void main() {
            vColor = color; vTwinkle = sin(uTime * 2.5 + twinkle) * 0.5 + 0.5;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            gl_PointSize = size * uPixelRatio * (300.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
        }`,
    fragmentShader: `
        varying vec3 vColor; varying float vTwinkle;
        void main() {
            float dist = distance(gl_PointCoord, vec2(0.5));
            float cross = abs(gl_PointCoord.x - 0.5) + abs(gl_PointCoord.y - 0.5);
            if (cross > 0.5) discard;
            float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
            alpha *= (0.2 + vTwinkle * 0.8);
            gl_FragColor = vec4(vColor, alpha);
        }`,
    transparent: true, vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false
});
const stars = new THREE.Points(starGeometry, starMaterial);
scene.add(stars);

const eventHorizonGeom = new THREE.SphereGeometry(BLACK_HOLE_RADIUS * 1.05, 128, 64);
const eventHorizonMat = new THREE.ShaderMaterial({
    uniforms: { uTime: { value: 0 }, uCameraPosition: { value: camera.position } },
    vertexShader: `
        varying vec3 vNormal; varying vec3 vPosition;
        void main() {
            vNormal = normalize(normalMatrix * normal); vPosition = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }`,
    fragmentShader: `
        uniform float uTime; uniform vec3 uCameraPosition;
        varying vec3 vNormal; varying vec3 vPosition;
        void main() {
            vec3 viewDirection = normalize(uCameraPosition - vPosition);
            float fresnel = 1.0 - abs(dot(vNormal, viewDirection));
            fresnel = pow(fresnel, 2.0); vec3 glowColor = vec3(0.0, 1.0, 0.8);
            float pulse = sin(uTime * 3.5) * 0.2 + 0.8;
            gl_FragColor = vec4(glowColor * fresnel * pulse, fresnel * 0.5);
        }`,
    transparent: true, blending: THREE.AdditiveBlending, side: THREE.BackSide
});
const eventHorizon = new THREE.Mesh(eventHorizonGeom, eventHorizonMat);
scene.add(eventHorizon);

const blackHoleGeom = new THREE.SphereGeometry(BLACK_HOLE_RADIUS, 128, 64);
const blackHoleMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
const blackHoleMesh = new THREE.Mesh(blackHoleGeom, blackHoleMat);
blackHoleMesh.renderOrder = 0;
scene.add(blackHoleMesh);

const diskGeometry = new THREE.RingGeometry(DISK_INNER_RADIUS, DISK_OUTER_RADIUS, 256, 128);
const diskMaterial = new THREE.ShaderMaterial({
    uniforms: {
        uTime: { value: 0.0 }, uColorHot: { value: new THREE.Color(0xffffff) },
        uColorMid1: { value: new THREE.Color(0xff00ff) }, uColorMid2: { value: new THREE.Color(0x00ffff) },
        uColorOuter: { value: new THREE.Color(0x3939f5) }, uNoiseScale: { value: 3.5 },
        uFlowSpeed: { value: 0.25 }, uDensity: { value: 1.5 }
    },
    vertexShader: `
        varying vec2 vUv; varying float vRadius; varying float vAngle;
        void main() {
            vUv = uv; vRadius = length(position.xy); vAngle = atan(position.y, position.x);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }`,
    fragmentShader: `
        uniform float uTime; uniform vec3 uColorHot; uniform vec3 uColorMid1; uniform vec3 uColorMid2; uniform vec3 uColorOuter;
        uniform float uNoiseScale; uniform float uFlowSpeed; uniform float uDensity;
        varying vec2 vUv; varying float vRadius; varying float vAngle;
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
        float snoise(vec3 v) {
            const vec2 C = vec2(1.0/6.0, 1.0/3.0); const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
            vec3 i = floor(v + dot(v, C.yyy)); vec3 x0 = v - i + dot(i, C.xxx);
            vec3 g = step(x0.yzx, x0.xyz); vec3 l = 1.0 - g; vec3 i1 = min(g.xyz, l.zxy); vec3 i2 = max(g.xyz, l.zxy);
            vec3 x1 = x0 - i1 + C.xxx; vec3 x2 = x0 - i2 + C.yyy; vec3 x3 = x0 - D.yyy;
            i = mod289(i); vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
            float n_ = 0.142857142857; vec3 ns = n_ * D.wyz - D.xzx; vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
            vec4 x_ = floor(j * ns.z); vec4 y_ = floor(j - 7.0 * x_); vec4 x = x_ * ns.x + ns.yyyy; vec4 y = y_ * ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y); vec4 b0 = vec4(x.xy, y.xy); vec4 b1 = vec4(x.zw, y.zw);
            vec4 s0 = floor(b0) * 2.0 + 1.0; vec4 s1 = floor(b1) * 2.0 + 1.0; vec4 sh = -step(h, vec4(0.0));
            vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy; vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;
            vec3 p0 = vec3(a0.xy, h.x); vec3 p1 = vec3(a0.zw, h.y); vec3 p2 = vec3(a1.xy, h.z); vec3 p3 = vec3(a1.zw, h.w);
            vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
            p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
            vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);
            m = m * m; return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));
        }
        void main() {
            float normalizedRadius = smoothstep(1.50, 8.00, vRadius);
            float timeOffset = uTime * uFlowSpeed * (2.0 / (vRadius * 0.3 + 1.0));
            vec2 noiseUv = vec2(vAngle * 2.0 + timeOffset, vRadius * 0.5);
            float noiseVal1 = snoise(vec3(noiseUv * uNoiseScale, uTime * 0.15));
            float noiseVal2 = snoise(vec3(noiseUv * uNoiseScale * 2.0 + 0.8, uTime * 0.22));
            float noiseVal = (noiseVal1 * 0.6 + noiseVal2 * 0.4); noiseVal = (noiseVal + 1.0) * 0.5;
            vec3 color = mix(uColorOuter, uColorMid2, smoothstep(0.0, 0.4, normalizedRadius));
            color = mix(color, uColorMid1, smoothstep(0.3, 0.7, normalizedRadius));
            color = mix(color, uColorHot, smoothstep(0.65, 0.95, normalizedRadius));
            float brightness = pow(1.0 - normalizedRadius, 1.2) * 3.0 + 0.5;
            brightness *= (0.3 + noiseVal * 2.2);
            float radialGrid = 1.0 - (sin(vRadius * 3.0 - uTime * 0.5) * 0.5 + 0.5);
            radialGrid = pow(radialGrid, 4.0); float angleGrid = 1.0 - (sin(vAngle * 20.0) * 0.5 + 0.5);
            angleGrid = pow(angleGrid, 4.0); float grid = 1.0 - clamp(radialGrid + angleGrid, 0.0, 1.0);
            brightness *= (0.7 + grid * 0.8); float alpha = uDensity * (0.2 + noiseVal * 0.9);
            alpha *= smoothstep(0.0, 0.15, normalizedRadius); alpha *= (1.0 - smoothstep(0.85, 1.0, normalizedRadius));
            alpha = clamp(alpha, 0.0, 1.0); gl_FragColor = vec4(color * brightness, alpha);
        }`,
    transparent: true, side: THREE.DoubleSide, depthWrite: false, blending: THREE.AdditiveBlending
});
const accretionDisk = new THREE.Mesh(diskGeometry, diskMaterial);
accretionDisk.rotation.x = DISK_TILT_ANGLE;
accretionDisk.renderOrder = 1;
scene.add(accretionDisk);

const gridHelper = new THREE.GridHelper(100, 50, 0x00ffff, 0x00ffff);
gridHelper.material.opacity = 0.1;
gridHelper.material.transparent = true;
gridHelper.material.blending = THREE.AdditiveBlending;
gridHelper.position.y = -10;
scene.add(gridHelper);

setTimeout(() => { const info = document.getElementById('info'); if (info) info.style.opacity = '0'; }, 5000);

window.addEventListener('resize', () => {
    const w = hero.clientWidth;
    const h = hero.clientHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
    composer.setSize(w, h);
    bloomPass.resolution.set(w, h);
    lensingPass.uniforms.aspectRatio.value = w / h;
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
});

const glitchButton = document.getElementById('glitch-button');
let glitchAnimationId = null;

glitchButton.addEventListener('click', () => {
    if (glitchAnimationId) return;
    
    customGlitchPass.enabled = true;
    const duration = 1000;
    const startTime = performance.now();

    function animateGlitch(currentTime) {
        const elapsedTime = currentTime - startTime;
        const progress = Math.min(elapsedTime / duration, 1);
        const intensity = Math.sin(progress * Math.PI);
        customGlitchPass.uniforms.uIntensity.value = intensity;

        if (progress < 1) {
            glitchAnimationId = requestAnimationFrame(animateGlitch);
        } else {
            customGlitchPass.enabled = false;
            customGlitchPass.uniforms.uIntensity.value = 0;
            glitchAnimationId = null;
        }
    }

    glitchAnimationId = requestAnimationFrame(animateGlitch);
});

const clock = new THREE.Clock();
const blackHoleScreenPosVec3 = new THREE.Vector3();
function animate() {
    requestAnimationFrame(animate);
    const elapsedTime = clock.getElapsedTime();
    const deltaTime = clock.getDelta();
    
    if (customGlitchPass.enabled) {
         customGlitchPass.uniforms.uTime.value = elapsedTime;
    }

    diskMaterial.uniforms.uTime.value = elapsedTime;
    starMaterial.uniforms.uTime.value = elapsedTime;
    eventHorizonMat.uniforms.uTime.value = elapsedTime;
    eventHorizonMat.uniforms.uCameraPosition.value.copy(camera.position);

    blackHoleScreenPosVec3.copy(blackHoleMesh.position).project(camera);
    lensingPass.uniforms.blackHoleScreenPos.value.set(
        (blackHoleScreenPosVec3.x + 1) / 2,
        (blackHoleScreenPosVec3.y + 1) / 2
    );
    
    controls.update();
    
    stars.rotation.y += deltaTime * 0.003;
    accretionDisk.rotation.z += deltaTime * 0.005;

    composer.render(deltaTime);
}

animate();

// Make gutters allow page scroll and not intercept clicks unnecessarily
document.querySelectorAll('.hero-gutter').forEach(el => {
    el.addEventListener('wheel', (e) => {
        // Let the page scroll naturally
        // Do not preventDefault so scroll bubbles to window
    }, { passive: true });
});

// Reveal sections on scroll
const sections = document.querySelectorAll('.section');
const revealObserver = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
        if (entry.isIntersecting) entry.target.classList.add('in-view');
    });
}, { threshold: 0.15 });
sections.forEach(s => revealObserver.observe(s));

// (scroll cue removed)

// Dynamic glitch meter percentage
const glitchPercentage = document.getElementById('glitch-percentage');
const glitchLevel = document.querySelector('.glitch-level');

function updateGlitchMeter() {
    const randomValue = Math.floor(Math.random() * 9) + 80; // 80-86
    glitchPercentage.textContent = randomValue + '%';
    glitchLevel.style.width = randomValue + '%';
}

// Update every 2 seconds
setInterval(updateGlitchMeter, 2000);

// Initial update
updateGlitchMeter();

// Auto-trigger glitch effects on page load
function triggerGlitchEffect() {
    if (glitchAnimationId) return;
    
    customGlitchPass.enabled = true;
    const duration = 1000;
    const startTime = performance.now();

    function animateGlitch(currentTime) {
        const elapsedTime = currentTime - startTime;
        const progress = Math.min(elapsedTime / duration, 1);
        const intensity = Math.sin(progress * Math.PI);
        customGlitchPass.uniforms.uIntensity.value = intensity;

        if (progress < 1) {
            glitchAnimationId = requestAnimationFrame(animateGlitch);
        } else {
            customGlitchPass.enabled = false;
            customGlitchPass.uniforms.uIntensity.value = 0;
            glitchAnimationId = null;
        }
    }

    glitchAnimationId = requestAnimationFrame(animateGlitch);
}

// Trigger glitch effects twice on page load with delays
setTimeout(() => {
    triggerGlitchEffect();
}, 2000); // First glitch after 2 seconds

setTimeout(() => {
    triggerGlitchEffect();
}, 5000); // Second glitch after 5 seconds
</script>
